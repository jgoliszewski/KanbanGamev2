@using KanbanGame.Shared
@using KanbanGamev2.Client.Services
@inject IDragDropService DragDropService
@inject ISignalRService SignalRService

<div class="kanban-column @(IsDragOver ? "drag-over" : "")"
     data-column-id="@ColumnId"
     @ondragover="OnDragOver"
     @ondragover:preventDefault
     @ondragleave="OnDragLeave"
     @ondrop="OnDrop"
     @ondrop:preventDefault>
    <div class="column-header">
        <h5>@Title</h5>
        <span class="badge bg-secondary">@Cards.Count</span>
    </div>
    <div class="column-content">
        @foreach (var card in SortedCards)
        {
            <DraggableCard 
                Card="@card"
                ColumnId="@ColumnId"
                BoardType="@BoardType"
                OnCardMoved="@OnCardMoved"
                OnWorkAssigned="@OnWorkAssigned" />
        }
    </div>
</div>

@code {
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public string ColumnId { get; set; } = string.Empty;
    [Parameter] public BoardType BoardType { get; set; }
    [Parameter] public List<Card> Cards { get; set; } = new();
    [Parameter] public EventCallback<(Card card, string fromColumn, string toColumn)> OnCardMoved { get; set; }
    [Parameter] public EventCallback<(Card workCard, Employee employee)> OnWorkAssigned { get; set; }

    private bool IsDragOver => DragDropService.IsDragging && 
                               DragDropService.DragOverTargetId == ColumnId &&
                               DragDropService.DragOverTargetType == DragOverTargetType.Column &&
                               IsValidDropTarget();

    private List<Card> SortedCards
    {
        get
        {
            var sortedCards = new List<Card>();
            var employees = Cards.OfType<Employee>().Where(e => e.Status == EmployeeStatus.Active).ToList();
            var workItems = Cards.Where(c => c is KanbanTask || c is Feature).ToList();

            // Add employees first
            foreach (var employee in employees)
            {
                sortedCards.Add(employee);
                
                // Find and add assigned work items immediately after the employee
                var assignedWorkItems = workItems.Where(work => 
                {
                    if (work is KanbanTask task)
                        return task.AssignedToEmployeeId == employee.Id;
                    if (work is Feature feature)
                        return feature.AssignedToEmployeeId == employee.Id;
                    return false;
                }).ToList();
                
                sortedCards.AddRange(assignedWorkItems);
            }
            
            // Add any remaining unassigned work items at the end
            var assignedWorkItemIds = workItems
                .Where(work => 
                {
                    if (work is KanbanTask task)
                        return task.AssignedToEmployeeId.HasValue;
                    if (work is Feature feature)
                        return feature.AssignedToEmployeeId.HasValue;
                    return false;
                })
                .Select(w => w.Id)
                .ToHashSet();
                
            var unassignedWorkItems = workItems.Where(w => !assignedWorkItemIds.Contains(w.Id)).ToList();
            sortedCards.AddRange(unassignedWorkItems);
            
            return sortedCards;
        }
    }

    private bool IsValidDropTarget()
    {
        if (!DragDropService.IsDragging || DragDropService.DraggedCard == null || DragDropService.SourceColumnId == null)
            return false;

        return DragDropService.IsValidMove(BoardType, DragDropService.DraggedCard, DragDropService.SourceColumnId, ColumnId);
    }

    private void OnDragOver(DragEventArgs e)
    {
        if (DragDropService.IsDragging && DragDropService.SourceColumnId != ColumnId && IsValidDropTarget())
        {
            DragDropService.SetDropTarget(ColumnId);
            DragDropService.SetDragOverTarget(ColumnId, DragOverTargetType.Column);
            StateHasChanged();
        }
    }

    private void OnDragLeave(DragEventArgs e)
    {
        if (DragDropService.IsDragging && DragDropService.DragOverTargetId == ColumnId)
        {
            DragDropService.ClearDragOverTarget();
            StateHasChanged();
        }
    }

    private async void OnDrop(DragEventArgs e)
    {
        if (DragDropService.IsDragging && DragDropService.SourceColumnId != ColumnId && IsValidDropTarget())
        {
            var draggedCard = DragDropService.DraggedCard!;
            
            // Handle the card movement (unassignment will be handled in the board pages)
            await OnCardMoved.InvokeAsync((draggedCard, DragDropService.SourceColumnId!, ColumnId));
            
            // Notify other players about the board update
            await SignalRService.NotifyBoardUpdateAsync(BoardType.ToString(), ColumnId, draggedCard);
            
            // Add a small delay before clearing drag state to ensure proper cleanup
            await Task.Delay(100);
            DragDropService.ClearDrag();
            StateHasChanged();
        }
    }

    private bool IsBackwardMove(Card card, string targetColumn)
    {
        var fromColumn = DragDropService.SourceColumnId!;
        
        // Analysis board backward moves
        if (fromColumn == "analysis1" && targetColumn == "backlog") return true;
        if (fromColumn == "analysis2" && targetColumn == "waiting") return true;
        
        // Development board backward moves
        if (fromColumn == "backend-analysis" && targetColumn == "backend-backlog") return true;
        if (fromColumn == "frontend-analysis" && targetColumn == "frontend-backlog") return true;
        if (fromColumn == "backend-dev-doing" && targetColumn == "backend-dev-waiting") return true;
        if (fromColumn == "frontend-dev-doing" && targetColumn == "frontend-dev-waiting") return true;
        if (fromColumn == "backend-test-doing" && targetColumn == "backend-test-waiting") return true;
        if (fromColumn == "frontend-test-doing" && targetColumn == "frontend-test-waiting") return true;
        
        return false;
    }
} 